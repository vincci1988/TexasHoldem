package ahri;

import java.util.Vector;

import LSTMPlus.Util;
import holdem.ActionBase;
import holdem.AllIn;
import holdem.Call;
import holdem.Fold;
import holdem.Raise;
import holdem.TableInfo;
import opponent_model.Intel;

public class Exploiter extends Controller {

	Exploiter(Ahri me) {
		super(me);
		weights = new double[WVCnt][WVLength];
		for (int i = 0; i < WVCnt; i++) {
			Util.gaussianInit(weights[i], 0.5, 0.1);
			rangeCheck(weights[i]);
		}
	}

	Exploiter(Ahri me, double[] genome) throws Exception {
		super(me);
		weights = new double[WVCnt][];
		for (int i = 0; i < WVCnt; i++) {
			weights[i] = Util.subArray(genome, WVLength * i, WVLength);
		}
	}

	public static int getGenomeLength() {
		return WVCnt * WVLength;
	}

	public double[] getGenome() {
		double[] genome = null;
		for (int i = 0; i < weights.length; i++) {
			rangeCheck(weights[i]);
			genome = Util.concat(genome, weights[i]);
		}
		return genome;
	}

	@Override
	public ActionBase recommend(Vector<ActionBase> actions, TableInfo info, String holeCards, Intel intel)
			throws Exception {
		init(actions, info, intel);
		int best = 0;
		double maxScore = Double.NEGATIVE_INFINITY;
		int betCnt = intel.getBetCnt();
		double handStrength = evaluator.getHandStength(holeCards, info.board, 1);
		for (int i = 0; i < actions.size(); i++) {
			if (betCnt > 1 && info.board.length() < 10 && info.currentBet < player.getMyBet() + player.getMyStack()) {
				if (actions.get(i) instanceof AllIn || actions.get(i) instanceof Raise)
					handStrength = Math.pow(handStrength, 2);
			}
			double score = evaluate(info, handStrength, i);
			if (score > maxScore) {
				maxScore = score;
				best = i;
			}
		}
		return actions.get(best);
	}

	double evaluate(TableInfo info, double handStrength, int i) throws Exception {
		double myTotalBet = (info.potSize - info.currentBet - player.getMyBet()) / 2 + player.getMyBet();
		if (actions.get(i) instanceof Fold)
			return -myTotalBet;
		double extraChips = 0;
		if (actions.get(i) instanceof Call) {
			extraChips = info.currentBet - player.getMyBet();
		}
		if (actions.get(i) instanceof Raise) {
			extraChips = ((Raise) actions.get(i)).getAmt() - player.getMyBet();
		}
		if (actions.get(i) instanceof AllIn) {
			extraChips = player.getMyStack();
		}
		double pw = getWinProb(i, handStrength);
		double pf = getFoldProb(i);
		double pl = 1 - pw;
		double ps = 1 - pf;
		return ps * (pw - pl) * (myTotalBet + extraChips) + pf * (info.potSize - myTotalBet);
	}

	private double getWinProb(int actionIndex, double handStrength) {
		double[] sumOfWeights = { 0, 0 };
		double mean = 0, std = 0;
		if (moves[actionIndex][3] > 1) {
			mean += moves[actionIndex][4] * weights[0][0];
			std += (Math.sqrt(moves[actionIndex][5] / (moves[actionIndex][3] - 1)
					- Math.pow(moves[actionIndex][4], 2) * moves[actionIndex][3] / (moves[actionIndex][3] - 1)))
					* weights[1][0];
			sumOfWeights[0] += weights[0][0];
			sumOfWeights[1] += weights[1][0];
		} else if (present[3] > 1) {
			mean += present[4] * weights[0][0];
			std += (Math.sqrt(present[5] / (present[3] - 1) - Math.pow(present[4], 2) * present[3] / (present[3] - 1)))
					* weights[1][0];
			sumOfWeights[0] += weights[0][0];
			sumOfWeights[1] += weights[1][0];
		}
		if (priors != null) {
			for (int weightIndex = 1, j = priors.length - 1; j >= 0; j--) {
				if (priors[j][3] > 1) {
					mean += priors[j][4] * weights[0][weightIndex];
					std += (Math.sqrt(priors[j][5] / (priors[j][3] - 1)
							- Math.pow(priors[j][4], 2) * priors[j][3] / (priors[j][3] - 1))) * weights[1][weightIndex];
					sumOfWeights[0] += weights[0][weightIndex];
					sumOfWeights[1] += weights[1][weightIndex];
					weightIndex++;
				}
			}
		}
		if (sumOfWeights[0] > 0 && sumOfWeights[1] > 0) {
			mean /= sumOfWeights[0];
			std /= sumOfWeights[1];
			return prob(mean, std, handStrength);
		}
		return Math.pow(handStrength, 2); 
	}

	private double getFoldProb(int actionIndex) {
		double ans = 0;
		double sumOfWeights = 0;
		if (moves[actionIndex][0] > 0) {
			ans += moves[actionIndex][1] / moves[actionIndex][0] * weights[2][0];
			sumOfWeights += weights[2][0];
		} else if (present[0] > 0) {
			ans += present[1] / present[0] * weights[2][0];
			sumOfWeights += weights[2][0];
		}
		if (priors != null) {
			for (int weightIndex = 1, j = priors.length - 1; j >= 0; j--) {
				if (priors[j][0] > 0) {
					ans += weights[2][weightIndex] * priors[j][1] / priors[j][0];
					sumOfWeights += weights[2][weightIndex];
					weightIndex++;
				}
			}
		}
		if (sumOfWeights > 0)
			ans /= sumOfWeights;
		return ans;
	}

	private static double prob(double m1, double dev, double x) {
		if (x <= m1 - 3 * dev)
			return 0;
		double ans = 0;
		double dy = 0.0001;
		double f1 = dy / dev / Math.sqrt(2 * Math.PI);
		double f2 = 2 * dev * dev;
		for (double y = m1 - 3 * dev; y < x; y += dy)
			ans += f1 * Math.exp(-Math.pow(y - m1, 2) / f2);
		return ans;
	}
	
	private void rangeCheck(double[] X) {
		for (int i = 0; i < X.length; i++)
			if (X[i] < 0) X[i] = 0;
	}

	static final int WVCnt = 3;
	static final int WVLength = 4;

	double[][] weights;
}
